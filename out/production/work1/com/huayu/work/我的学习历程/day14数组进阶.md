# 多维数组

## 二维数组

```java
//基本构架
int a[][]=new int[2][5]
    //可以看成一个两行三列的数组
```

其中每一个元素都是一维数组

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-21 215558.png)

还是很好理解的

二维数组如果我们只用一维的输出方法输出，只能输出一个数组，但我们知道数组被输出的只有地址，我们必须输出数组中的一个值才能有结果，所以这样是不行的，一定要精确到一个具体的数字

但我们可以通过之前的打印代码来查看这个数组的第二维

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-21 220342.png)

当然我们也可以使用打印二维数组的代码打印一整个数组

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-21 221430.png)

我们查看数组长度也是同理，我们用array.length只能查看一维的长度，我们要用array[第一维位置].length来查看某一维下二维数组的长度

# 数组应用

## Arrays类（关于数组的工具类）

1.打印数组Arrays.toString(),只能打印一维数组

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-22 105813.png)

2.排序数组升序，Arrays.sort()

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-22 111858.png)

3. 对数组赋值，fill

   ![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-22 112303.png)

   ![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-22 112433.png)

   第二幅图是让数组数值为2和数值为4之间的数值被0填充

4. 比较equal

5. 查找，binarySearch

利用JDK帮助文档查找

# 冒泡排序

比较数组中两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置，每一比较都会产生一个最大或最小的数字，下一轮则可以少一次排序，依次循环直到结束

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-22 115840.png)

交换两个数，通常要利用到第三个变量

像水杯倒水一样，利用第三个杯子将两杯的水进行互换

冒泡排序每轮都会产生一个最大或最小的数字，五个数中我们只要判断四次最大，最后一个数自然是最小，所以循环a.length-1次

对于j<a.length-1-i主要是因为取出一个最大值后只剩四个数需要判断，判断次数就变少了，i只是充当一个递减的数而已，刚好能用，当然我们也可以不-i，但-i可以让程序运行更快

改变判断符号就可以改变排序方向

时间复杂度O(n2)

## 利用flag标识符优化循环

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-22 121811.png)

利用flag标签，如果上一轮没有排序，说明排序已经完毕，不需要接着排，可以省去一些不必要的步骤，是一种优化思路
