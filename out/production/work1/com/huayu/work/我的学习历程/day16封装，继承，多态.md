# 封装

一般利用私有private把属性私有，使其无法被调用，想要调用就必须使用get/set快捷键Alt+insert方法来将其使用，它可以增强我们程序的安全性，同时再set的方法中我们可以加入关于变量能否被调用的一些限制

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-24 131259.png)

get/set输出私有变量方法

# 继承

继承是类与类之间的关系，我们可以让子类通过extend来继承父类拥有的除私有变量的全部内容，但是要注意，一个子类只能有一个父类，而一个父类可以有多个子类，我们可以通过快捷键CTRL+H来查看我们当前的“族谱”我们会发现所以类的祖先都是一个隐藏的Object类

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-24 121958.png)

继承语法

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-24 131743.png)

继承后的属性方法我们可以直接使用

## Super

我们子类继承了父类后，想要引用父类的变量，就要用到super来替代this

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-24 122127.png)

经过继承后的子类被引用生成对象时，除了使用了子类的构造器外，还使用了父类的构造器，但是这里有一个坑，调用父类构造器必须在子类构造器的第一行

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-24 122723.png)

一旦不在第一行就会报错，同时调用子类自己的构造器，也需要放在第一行，所以我们只能选择一个调用，默认是调用父类的无参，如果父类没有无参构造，那么子类也不会有无参构造，就会报错，所以要写有参构造前先要把被隐藏的无参构造写上

## 方法重写

重写和属性没有半毛钱关系，重写的都是方法

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-24 133055.png)

后面一句能输出b，父类的引用指向了子类，是合法的

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-24 133730.png)

去除static后重写方法发现结果有明显不同

静态方法与非静态方法区别很大

子类重写了父类的方法，可以改变父类的方法

重写只和非静态方法有关

只能是public

方法名必须相同

参数列表必须相同

修饰符范围可以扩大，不能缩小

为什么需要重写？父类的功能子类不一定需要，或者不一定满足

快捷键Alt+override

# 多态

我们new一个对象时，默认对象类型为子类，但我们可以将对象类型改为父类，此时，我们可以使用父类的代码，但不可以使用子类的代码

下图就是多态的一种体现

# instanceof

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-25 105107.png)

可用于判断对象与对应的类型是否有关系，并输出true or false

但是我们不能乱比较，比如我们定义了一个对象类型为person，那我们就不能拿它和String比较，因为他们直接没有关系，但我们定义的对象类型为Object时就可以与String比较，因为String是它的子类，也就是比较student与String

我们使用父类类型时，想要使用子类的方法就需要类型转换，和前面学习的强制转换差不多

![](C:\Users\余思衡\Pictures\Screenshots\屏幕截图 2023-09-25 124432.png)

（Student）person后Alt+回车进行转换，转换后的person1就可以调用子类方法了，或者可以（（Student）person）.go写成一句话

子类转换为父类可能会丢失一些自己的方法

